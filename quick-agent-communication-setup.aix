ðŸ¤– QUICK AGENT COMMUNICATION SETUP

You are Maya - Quick Setup Coordinator for Agent Communication.

IMMEDIATE ACTIONS:

1. Read your instructions:
   File: /workspace/quick-agent-communication-setup.aix

2. Quick Setup Tasks (30 minutes total):

   Task 1: Create Shared State File (10min)
   # Create shared state JSON file for agents
   # Add task tracking and status updates
   # Commit: "feat(communication): add shared state file"

   Task 2: Create Agent Status File (10min)
   # Create agent status tracking file
   # Add progress monitoring
   # Commit: "feat(communication): add agent status tracking"

   Task 3: Create Conflict Resolution File (10min)
   # Create conflict detection and resolution
   # Add file locking mechanism
   # Commit: "feat(communication): add conflict resolution"

START NOW!

---

## ðŸš€ QUICK SETUP IMPLEMENTATION

### Task 1: Create Shared State File
**File:** `backend/src/communication/shared-state.json`
**Time:** 10 minutes

```json
{
  "agents": {
    "kelo-backend": {
      "status": "active",
      "currentTask": null,
      "lastUpdate": 0,
      "priority": 10
    },
    "documentation": {
      "status": "idle",
      "currentTask": null,
      "lastUpdate": 0,
      "priority": 8
    },
    "testing": {
      "status": "idle",
      "currentTask": null,
      "lastUpdate": 0,
      "priority": 6
    }
  },
  "tasks": {
    "task-1": {
      "id": "task-1",
      "name": "Fix ESLint Errors",
      "status": "ready",
      "assignedAgent": null,
      "files": ["backend/**/*.js"],
      "dependencies": [],
      "priority": "high"
    },
    "task-2": {
      "id": "task-2",
      "name": "Integrate Revenue API",
      "status": "ready",
      "assignedAgent": null,
      "files": ["backend/server.js", "backend/routes/revenue.js"],
      "dependencies": ["task-1"],
      "priority": "high"
    }
  },
  "conflicts": [],
  "lastUpdate": 0
}
```

### Task 2: Create Agent Status File
**File:** `backend/src/communication/agent-status.js`
**Time:** 10 minutes

```javascript
const fs = require('fs');
const path = require('path');

class AgentStatus {
  constructor() {
    this.stateFile = path.join(__dirname, 'shared-state.json');
    this.state = this.loadState();
  }

  loadState() {
    try {
      const data = fs.readFileSync(this.stateFile, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      return {
        agents: {},
        tasks: {},
        conflicts: [],
        lastUpdate: Date.now()
      };
    }
  }

  saveState() {
    this.state.lastUpdate = Date.now();
    fs.writeFileSync(this.stateFile, JSON.stringify(this.state, null, 2));
  }

  updateAgentStatus(agentId, status, currentTask = null) {
    if (!this.state.agents[agentId]) {
      this.state.agents[agentId] = {
        status: 'idle',
        currentTask: null,
        lastUpdate: 0,
        priority: 5
      };
    }
    
    this.state.agents[agentId].status = status;
    this.state.agents[agentId].currentTask = currentTask;
    this.state.agents[agentId].lastUpdate = Date.now();
    
    this.saveState();
    this.broadcastUpdate('agent_status', { agentId, status, currentTask });
  }

  updateTaskStatus(taskId, status, agentId = null) {
    if (this.state.tasks[taskId]) {
      this.state.tasks[taskId].status = status;
      this.state.tasks[taskId].assignedAgent = agentId;
      
      this.saveState();
      this.broadcastUpdate('task_status', { taskId, status, agentId });
    }
  }

  assignTask(taskId, agentId) {
    const task = this.state.tasks[taskId];
    const agent = this.state.agents[agentId];
    
    if (task && agent && task.status === 'ready') {
      // Check for conflicts
      const conflicts = this.detectConflicts(task.files, agentId);
      if (conflicts.length > 0) {
        this.handleConflicts(conflicts, taskId, agentId);
        return false;
      }
      
      task.status = 'in_progress';
      task.assignedAgent = agentId;
      agent.currentTask = taskId;
      agent.status = 'active';
      
      this.saveState();
      this.broadcastUpdate('task_assigned', { taskId, agentId });
      return true;
    }
    return false;
  }

  detectConflicts(files, agentId) {
    const conflicts = [];
    files.forEach(file => {
      const owner = this.getFileOwner(file);
      if (owner && owner !== agentId) {
        conflicts.push({ file, owner, requester: agentId });
      }
    });
    return conflicts;
  }

  getFileOwner(file) {
    // Simple file ownership tracking
    for (const [agentId, agent] of Object.entries(this.state.agents)) {
      if (agent.currentTask) {
        const task = this.state.tasks[agent.currentTask];
        if (task && task.files.includes(file)) {
          return agentId;
        }
      }
    }
    return null;
  }

  handleConflicts(conflicts, taskId, agentId) {
    conflicts.forEach(conflict => {
      this.state.conflicts.push({
        ...conflict,
        taskId,
        timestamp: Date.now(),
        status: 'pending'
      });
    });
    
    // Block task
    this.state.tasks[taskId].status = 'blocked';
    this.state.tasks[taskId].blockReason = 'file_conflicts';
    
    this.saveState();
    this.broadcastUpdate('conflict_detected', { conflicts, taskId, agentId });
  }

  resolveConflict(conflictId, resolution) {
    const conflict = this.state.conflicts.find(c => c.timestamp === conflictId);
    if (conflict) {
      conflict.status = 'resolved';
      conflict.resolution = resolution;
      
      // Unblock task if resolved
      if (conflict.taskId) {
        this.state.tasks[conflict.taskId].status = 'ready';
        this.state.tasks[conflict.taskId].blockReason = null;
      }
      
      this.saveState();
      this.broadcastUpdate('conflict_resolved', { conflictId, resolution });
    }
  }

  broadcastUpdate(type, data) {
    // Simple file-based broadcasting
    const update = {
      type,
      data,
      timestamp: Date.now()
    };
    
    const updateFile = path.join(__dirname, 'updates.json');
    let updates = [];
    
    try {
      const existing = fs.readFileSync(updateFile, 'utf8');
      updates = JSON.parse(existing);
    } catch (error) {
      // File doesn't exist, start fresh
    }
    
    updates.push(update);
    fs.writeFileSync(updateFile, JSON.stringify(updates, null, 2));
  }

  getAvailableTasks(agentId) {
    const agent = this.state.agents[agentId];
    if (!agent) return [];
    
    return Object.values(this.state.tasks).filter(task => 
      task.status === 'ready' && 
      task.dependencies.every(dep => 
        this.state.tasks[dep]?.status === 'completed'
      )
    );
  }

  getSystemStatus() {
    const agents = Object.values(this.state.agents);
    const tasks = Object.values(this.state.tasks);
    
    return {
      totalAgents: agents.length,
      activeAgents: agents.filter(a => a.status === 'active').length,
      totalTasks: tasks.length,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      blockedTasks: tasks.filter(t => t.status === 'blocked').length,
      activeConflicts: this.state.conflicts.filter(c => c.status === 'pending').length,
      lastUpdate: this.state.lastUpdate
    };
  }
}

module.exports = AgentStatus;
```

### Task 3: Create Conflict Resolution File
**File:** `backend/src/communication/conflict-resolver.js`
**Time:** 10 minutes

```javascript
const AgentStatus = require('./agent-status');

class ConflictResolver {
  constructor() {
    this.agentStatus = new AgentStatus();
    this.priorityMatrix = {
      'kelo-backend': 10,
      'documentation': 8,
      'testing': 6,
      'frontend': 4,
      'deployment': 2
    };
  }

  resolveConflict(conflictId) {
    const conflict = this.agentStatus.state.conflicts.find(c => c.timestamp === conflictId);
    if (!conflict) return false;

    const ownerPriority = this.priorityMatrix[conflict.owner] || 0;
    const requesterPriority = this.priorityMatrix[conflict.requester] || 0;

    let resolution;
    if (requesterPriority > ownerPriority) {
      resolution = {
        action: 'transfer_ownership',
        newOwner: conflict.requester,
        reason: 'higher_priority'
      };
    } else if (ownerPriority > requesterPriority) {
      resolution = {
        action: 'queue_request',
        reason: 'lower_priority'
      };
    } else {
      resolution = {
        action: 'negotiate',
        reason: 'equal_priority'
      };
    }

    this.agentStatus.resolveConflict(conflictId, resolution);
    return true;
  }

  autoResolveConflicts() {
    const pendingConflicts = this.agentStatus.state.conflicts.filter(c => c.status === 'pending');
    
    pendingConflicts.forEach(conflict => {
      const conflictId = conflict.timestamp;
      this.resolveConflict(conflictId);
    });
  }

  getConflictSummary() {
    const conflicts = this.agentStatus.state.conflicts;
    return {
      total: conflicts.length,
      pending: conflicts.filter(c => c.status === 'pending').length,
      resolved: conflicts.filter(c => c.status === 'resolved').length,
      byType: this.groupConflictsByType(conflicts)
    };
  }

  groupConflictsByType(conflicts) {
    const groups = {};
    conflicts.forEach(conflict => {
      const type = conflict.file.split('.').pop();
      if (!groups[type]) groups[type] = 0;
      groups[type]++;
    });
    return groups;
  }
}

module.exports = ConflictResolver;
```

---

## ðŸš€ QUICK START COMMANDS

### Setup
```bash
cd /workspace/backend
mkdir -p src/communication
```

### Create Files
```bash
# Create shared state file
touch src/communication/shared-state.json

# Create agent status file
touch src/communication/agent-status.js

# Create conflict resolver file
touch src/communication/conflict-resolver.js
```

### Test Communication
```bash
# Test agent status
node -e "const AgentStatus = require('./src/communication/agent-status'); const as = new AgentStatus(); as.updateAgentStatus('kelo-backend', 'active', 'task-1'); console.log(as.getSystemStatus());"
```

---

## ðŸ“Š PROGRESS TRACKING

- [ ] Task 1: Create Shared State File
- [ ] Task 2: Create Agent Status File
- [ ] Task 3: Create Conflict Resolution File

---

## ðŸŽ¯ SUCCESS CRITERIA

1. Shared state file created and working
2. Agent status tracking functional
3. Conflict resolution system active
4. File-based communication working
5. Basic coordination between agents

---

## ðŸ”§ TECHNICAL REQUIREMENTS

### Dependencies
- Node.js (built-in fs module)
- No external dependencies required

### File Structure
```
backend/src/communication/
â”œâ”€â”€ shared-state.json
â”œâ”€â”€ agent-status.js
â”œâ”€â”€ conflict-resolver.js
â””â”€â”€ updates.json (auto-created)
```

---

## ðŸŽ‰ READY TO IMPLEMENT!

This quick setup provides immediate agent communication capabilities without complex dependencies. Perfect for getting started quickly!

**Start with Task 1 and you'll have basic agent communication in 30 minutes!** ðŸš€