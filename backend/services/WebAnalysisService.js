
require('dotenv').config();
const axios = require('axios');
const { JSDOM } = require('jsdom');
const { Readability } = require('@mozilla/readability');

// --- Mock/Placeholder Clients ---

// This is a placeholder for the actual Gemini client.
const geminiClient = {
  /**
   * @param {string} prompt
   * @returns {Promise<any>}
   */
  async generateContent(prompt) {
    console.log('--- FAKE GEMINI CALL ---');
    const fakeAnalysis = `
      <p>Based on the provided sources, here is a synthesized answer to your question. This answer is generated by combining information from multiple web pages to provide a comprehensive overview.</p>
      <h3>Key Points:</h3>
      <ul>
        <li>The first key point from the web search results.</li>
        <li>The second key point, integrating information from another source.</li>
        <li>A concluding point based on the synthesized data.</li>
      </ul>
      <p>Sources:</p>
      <ol>
        <li>Source URL 1</li>
        <li>Source URL 2</li>
      </ol>
    `;
    return Promise.resolve({ response: { text: () => fakeAnalysis } });
  }
};

/**
 * This is a placeholder for the Google Search API call.
 * @param {string} query
 * @returns {Promise<any>}
 */
async function googleSearch(query) {
    console.log(`--- FAKE GOOGLE SEARCH for "${query}" ---`);
    // In a real implementation, this would use axios to call the Google Custom Search API.
    return Promise.resolve([
        {
            title: 'Mock Search Result 1',
            link: 'https://www.example.com/article1',
            snippet: 'This is a mock snippet for the first search result.'
        },
        {
            title: 'Mock Search Result 2',
            link: 'https://www.example.com/article2',
            snippet: 'This is a mock snippet for the second search result.'
        }
    ]);
}

// --- WebAnalysisService Class ---
/**
 * @class WebAnalysisService
 */
class WebAnalysisService {
  /**
   * @param {any} geminiClient
   */
  constructor(geminiClient) {
    this.geminiClient = geminiClient;
  }

  /**
   * Fetches the content of a URL and cleans it using @mozilla/readability.
   * @private
   * @param {string} url The URL to fetch and clean.
   * @returns {Promise<object|null>} An object with title and textContent, or null on failure.
   */
  async _fetchAndCleanUrl(url) {
    try {
      const response = await axios.get(url, { timeout: 8000 });
      const dom = new JSDOM(response.data, { url });
      const reader = new Readability(dom.window.document);
      const article = reader.parse();
      
      if (article) {
        return {
            title: article.title,
            content: article.textContent.trim().replace(/\s\s+/g, ' ') // Clean up whitespace
        };
      } else {
        console.warn(`[WebAnalysisService] Readability could not parse content from ${url}`);
        return null;
      }
    } catch (error) {
      console.error(`[WebAnalysisService] Failed to fetch or parse URL ${url}:`, error.message);
      return null;
    }
  }

  /**
   * Performs a web search, fetches content from top results, and synthesizes an answer.
   * @param {string} question The user's question.
   * @returns {Promise<string>} The AI-generated answer as HTML.
   */
  async getAnswerFromWeb(question) {
    console.log(`[WebAnalysisService] Received question: "${question}"`);

    // 1. Retrieve search results
    const searchResults = await googleSearch(question);
    if (!searchResults || searchResults.length === 0) {
      return '<p>Could not find any relevant web pages for your query.</p>';
    }

    // 2. Fetch and clean content from the top results in parallel
    console.log(`[WebAnalysisService] Fetching content from ${searchResults.length} URLs...`);
    const fetchPromises = searchResults.map(result => this._fetchAndCleanUrl(result.link));
    const fetchedContents = (await Promise.all(fetchPromises)).filter(Boolean); // Filter out nulls

    if (fetchedContents.length === 0) {
        return '<p>Could not fetch content from any of the top web pages.</p>';
    }

    // 3. Augment: Prepare the context for the generation step
    const context = fetchedContents.map((item, index) => {
        return `Source ${index + 1} (Title: ${item.title}):\n${item.content}`;
    }).join('\n\n---\n\n');

    const sourceLinks = searchResults.map(r => r.link);

    // 4. Generate: Synthesize an answer using the fetched content
    console.log('[WebAnalysisService] Synthesizing answer with AI...');
    const prompt = `Based ONLY on the following sources, please provide a comprehensive answer to the user's question.
    User Question: "${question}"

    Sources:
    ${context}

    Your answer should be in HTML format. You MUST cite the sources by including the source links at the end of your answer. The source links are: ${sourceLinks.join(', ')}`;

    try {
      const result = await this.geminiClient.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error('[WebAnalysisService] Error synthesizing answer with Gemini:', error);
      return '<p>Error synthesizing an answer from the web content.</p>';
    }
  }

   /**
   * Fetches and analyzes a single URL.
   * @param {string} url The URL to analyze.
   * @returns {Promise<string>} The AI-generated analysis as HTML.
   */
  async analyzeUrl(url) {
    console.log(`[WebAnalysisService] Analyzing URL: ${url}`);
    const cleanedContent = await this._fetchAndCleanUrl(url);

    if (!cleanedContent) {
        return `<p>Could not retrieve or parse content from the URL: ${url}</p>`;
    }

    const prompt = `Please provide a detailed summary, identify key topics, and give a sentiment analysis (Positive, Negative, Neutral) for the following web page content. Format the output as HTML.

    Content:
    ${cleanedContent.content}`;
    
    try {
      const result = await this.gemm_iniClient.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error(`[WebAnalysisService] Error analyzing URL ${url} with Gemini:`, error);
      return '<p>Error analyzing the URL content.</p>';
    }
  }
}

// Export a singleton instance of the service
module.exports = new WebAnalysisService(geminiClient);
