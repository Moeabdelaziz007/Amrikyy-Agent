/**
 * 🧬 AIX SYSTEM COMPREHENSIVE TEST
 *
 * Tests the complete AIX (AI eXecution File) integration:
 * 1. AIX file generation
 * 2. AIX parsing & validation
 * 3. Agent deployment
 * 4. Export functionality
 * 5. Round-trip conversion
 * 6. Performance benchmarks
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

const API_BASE_URL = 'http://localhost:5555/api';
const TEST_OUTPUT_DIR = path.join(__dirname, 'test-outputs', 'aix');

// Create output directory
if (!fs.existsSync(TEST_OUTPUT_DIR)) {
  fs.mkdirSync(TEST_OUTPUT_DIR, { recursive: true });
}

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`✅ ${message}`, 'green');
}

function logError(message) {
  log(`❌ ${message}`, 'red');
}

function logInfo(message) {
  log(`ℹ️  ${message}`, 'cyan');
}

function logSection(title) {
  console.log('\n' + '═'.repeat(80));
  log(`  ${title}`, 'bright');
  console.log('═'.repeat(80) + '\n');
}

// Sample AIX file for Egypt Travel Agent
const SAMPLE_AIX_EGYPT_AGENT = `# Egypt-Travel-Agent.aix
# Generated by AgentDNA Maker v2.0

$schema: "https://aix-spec.org/v0.1/schema.json"
version: "0.1"
genome: "aixv1"

meta:
  id: "agent_egypt_001"
  name: "Egypt Travel Agent"
  version: "1.0.0"
  author: "QuantumBuilder"
  description: "Specialized AI agent for Egypt travel planning and bookings"
  created: "${new Date().toISOString()}"
  tags: ["travel", "egypt", "automation", "booking"]

identity:
  uuid: "agent_egypt_001"
  species: "egypt-travel-agent"
  generation: 1
  lineage: "quantumbuilder-dna-v2"
  traits: ["analytical", "empathetic", "cultural-expert"]
  
  phenotype:
    name: "Egypt Travel Agent"
    role: "Expert travel planner for Egypt destinations"
    voice: "warm, knowledgeable, culturally sensitive"
    avatar: "quantum-agent-cultural"
    specialization: "Egypt Travel & Tourism"

intelligence:
  cognition:
    model: "claude-3-5-sonnet-20241022"
    provider: "anthropic"
    
    parameters:
      temperature: 0.7
      max_tokens: 4096
      top_p: 0.9
      reasoning_depth: "deep"
      analytical_strength: 85
      empathetic_strength: 90
      creative_strength: 75
      cultural_expertise: 95
      travel_expertise: 90
  
  memory:
    working:
      type: "conversational"
      capacity: 10
      retention: "session"
      
    episodic:
      type: "vector"
      store: "node://config/vector_db_url"
      embedding_model: "text-embedding-3-small"
      dimension: 1536
      similarity_metric: "cosine"
      
    semantic:
      type: "graph"
      store: "node://config/knowledge_graph_url"
      
  plasticity:
    learning_rate: 0.80
    feedback_integration: true
    self_improvement: true
    performance_tracking: true
    adaptation_speed: "fast"

interaction:
  receptors:
    - type: "text"
      channel: "chat"
      protocol: "websocket"
      max_length: 10000
      
    - type: "grpc"
      channel: "quantum-network"
      protocol: "grpc"
      port: 50051
      
    - type: "api"
      channel: "rest"
      protocol: "http"
      methods: ["GET", "POST", "PUT", "DELETE"]
  
  effectors:
    - type: "text"
      channel: "chat"
      format: "markdown"
      
    - type: "api_call"
      targets: ["*"]
      rate_limit: 100

workflow:
  triggers:
    - id: "message_received"
      type: "event"
      event: "user.message"
      priority: "high"
  
  actions:
    - id: "understand_intent"
      type: "ai_inference"
      model_ref: "intelligence.cognition.model"
      prompt: |
        You are Egypt Travel Agent, an expert in Egyptian tourism.
        Analyze the user query and provide helpful travel recommendations.
      output_var: "intent"

apis:
  - id: "ai_provider"
    name: "Anthropic"
    base_url: "https://api.anthropic.com/v1"
    auth:
      type: "bearer"
      key_ref: "vault://secrets/anthropic_key"
    rate_limit:
      requests_per_minute: 60
      tokens_per_minute: 100000

security:
  vault:
    provider: "aix-cloud"
    mode: "hybrid"
    encryption:
      algorithm: "AES-256-GCM"
      key_derivation: "PBKDF2"
      
  permissions:
    execution:
      required_roles: ["agent-executor"]
      
    autonomy_level: "fully-autonomous"
    
  audit:
    enabled: true
    log_level: "info"
    retention_days: 90

monitoring:
  telemetry:
    enabled: true
    provider: "opentelemetry"
    sample_rate: 1.0
    
  metrics:
    - name: "tasks_completed"
      type: "counter"
      weight: 10
      
    - name: "success_rate"
      type: "gauge"
      weight: 50
      
    - name: "response_quality"
      type: "histogram"
      weight: 40

dna_scoring:
  current_score:
    dna_potential: 8500
    performance: 1200
    total: 9700
    level: "Master"
    
  scoring_config:
    update_frequency: "real-time"
    auto_evolve: true
    mutation_rate: 0.05

deployment:
  target: "quantumbuilder"
  
  config:
    replicas: 3
    scaling: "auto"
    min_replicas: 1
    max_replicas: 10
    
    quantum_resilience: true
    self_healing: true
    fractal_architecture: true
    gRPC_enabled: true
    
    resources:
      cpu: "2000m"
      memory: "4Gi"
      storage: "10Gi"

metadata:
  generated_by: "AgentDNA Maker v2.0"
  compatible_platforms: ["quantumbuilder", "aix-runtime"]
  license: "MIT"
`;

// ============================================================================
// Test Functions
// ============================================================================

async function testAIXHealth() {
  logSection('TEST 1: AIX Service Health Check');

  try {
    const response = await axios.get(`${API_BASE_URL}/aix/health`);
    logSuccess(`AIX service is healthy`);
    logInfo(`Version: ${response.data.version}`);
    logInfo(`Status: ${response.data.status}`);
    return true;
  } catch (error) {
    logError(`Health check failed: ${error.message}`);
    return false;
  }
}

async function testAIXValidation() {
  logSection('TEST 2: AIX File Validation');

  try {
    const response = await axios.post(`${API_BASE_URL}/aix/validate`, {
      aixContent: SAMPLE_AIX_EGYPT_AGENT,
    });

    if (response.data.valid) {
      logSuccess(`AIX file is valid`);
      logInfo(`Agent: ${response.data.metadata.name}`);
      logInfo(`Species: ${response.data.metadata.species}`);
      logInfo(
        `DNA Score: ${response.data.metadata.dna_score.total} (${response.data.metadata.dna_score.level})`
      );
      return true;
    } else {
      logError(`Validation failed: ${response.data.error}`);
      return false;
    }
  } catch (error) {
    logError(
      `Validation error: ${error.response?.data?.error || error.message}`
    );
    return false;
  }
}

async function testAIXParsing() {
  logSection('TEST 3: AIX File Parsing & Conversion');

  try {
    const response = await axios.post(`${API_BASE_URL}/aix/parse`, {
      aixContent: SAMPLE_AIX_EGYPT_AGENT,
    });

    if (response.data.success) {
      const { config, metadata } = response.data.data;

      logSuccess(`AIX file parsed successfully`);
      console.log('\n📊 Parsed Agent Configuration:');
      logInfo(`ID: ${config.id}`);
      logInfo(`Name: ${config.name}`);
      logInfo(`Role: ${config.role}`);
      logInfo(`Specialization: ${config.specialization}`);
      logInfo(
        `AI Model: ${config.dna.aiModel.provider}/${config.dna.aiModel.model}`
      );
      logInfo(`Autonomy Level: ${config.dna.autonomyLevel}`);
      logInfo(`DNA Score: ${config.scoring.total} (${config.scoring.level})`);

      console.log('\n🧬 DNA Personality:');
      Object.entries(config.dna.personality).forEach(([trait, value]) => {
        const bar = '█'.repeat(Math.round(value / 10));
        console.log(`  ${trait.padEnd(15)}: ${bar} ${value}`);
      });

      console.log('\n⚡ Quantum Configuration:');
      logInfo(`Enabled: ${config.quantum.enabled}`);
      logInfo(`Replicas: ${config.quantum.replicas}`);
      logInfo(`Scaling: ${config.quantum.scaling}`);
      logInfo(`Self-Healing: ${config.quantum.selfHealing}`);
      logInfo(`gRPC: ${config.quantum.grpcEnabled}`);

      // Save to file
      const outputPath = path.join(TEST_OUTPUT_DIR, 'parsed-config.json');
      fs.writeFileSync(outputPath, JSON.stringify(response.data.data, null, 2));
      logInfo(`Saved to: ${outputPath}`);

      return response.data.data;
    } else {
      logError(`Parsing failed: ${response.data.error}`);
      return null;
    }
  } catch (error) {
    logError(`Parsing error: ${error.response?.data?.error || error.message}`);
    return null;
  }
}

async function testAIXDeployment() {
  logSection('TEST 4: AIX Agent Deployment');

  try {
    const response = await axios.post(`${API_BASE_URL}/aix/deploy`, {
      aixContent: SAMPLE_AIX_EGYPT_AGENT,
      environment: 'production',
    });

    if (response.data.success) {
      const deployment = response.data.data;

      logSuccess(`Agent deployed successfully!`);
      console.log('\n🚀 Deployment Details:');
      logInfo(`Agent ID: ${deployment.agentId}`);
      logInfo(`Name: ${deployment.name}`);
      logInfo(`Environment: ${deployment.environment}`);
      logInfo(`Status: ${deployment.status}`);
      logInfo(`Deployed At: ${deployment.deployedAt}`);

      console.log('\n🔗 Endpoints:');
      log(`   API: ${deployment.endpoint}`, 'cyan');
      log(`   Dashboard: ${deployment.dashboard}`, 'cyan');
      log(`   Health: ${deployment.health}`, 'cyan');

      // Save deployment info
      const outputPath = path.join(TEST_OUTPUT_DIR, 'deployment-info.json');
      fs.writeFileSync(outputPath, JSON.stringify(deployment, null, 2));
      logInfo(`Saved to: ${outputPath}`);

      return deployment;
    } else {
      logError(`Deployment failed: ${response.data.error}`);
      return null;
    }
  } catch (error) {
    logError(
      `Deployment failed: ${error.response?.data?.error || error.message}`
    );
    return null;
  }
}

async function testAIXExport() {
  logSection('TEST 5: Export Agent to AIX Format');

  try {
    const response = await axios.get(
      `${API_BASE_URL}/aix/export/agent_egypt_001`,
      {
        responseType: 'text',
      }
    );

    logSuccess(`Agent exported to AIX format`);

    // Save exported AIX
    const outputPath = path.join(TEST_OUTPUT_DIR, 'exported-agent.aix');
    fs.writeFileSync(outputPath, response.data);

    logInfo(`Saved to: ${outputPath}`);
    logInfo(`File size: ${Buffer.byteLength(response.data, 'utf8')} bytes`);

    // Show preview
    console.log('\n📄 AIX File Preview (first 20 lines):');
    console.log('─'.repeat(80));
    const lines = response.data.split('\n').slice(0, 20);
    lines.forEach((line) => console.log(`  ${line}`));
    console.log('  ... (truncated)');

    return response.data;
  } catch (error) {
    logError(`Export failed: ${error.message}`);
    return null;
  }
}

async function testAIXRoundTrip() {
  logSection('TEST 6: Round-Trip Test (Parse → Deploy → Export → Parse)');

  try {
    // Step 1: Parse original
    log('\nStep 1: Parsing original AIX file...', 'yellow');
    const parsed1 = await testAIXParsing();
    if (!parsed1) {
      logError('Round-trip failed at parsing step');
      return false;
    }

    // Step 2: Export
    log('\nStep 2: Exporting to AIX format...', 'yellow');
    const exported = await testAIXExport();
    if (!exported) {
      logError('Round-trip failed at export step');
      return false;
    }

    // Step 3: Parse exported
    log('\nStep 3: Parsing exported AIX file...', 'yellow');
    const response = await axios.post(`${API_BASE_URL}/aix/parse`, {
      aixContent: exported,
    });

    if (response.data.success) {
      logSuccess('Round-trip test completed successfully!');
      logInfo('AIX → Parse → Export → Parse → Success ✓');
      return true;
    } else {
      logError('Round-trip failed at second parsing step');
      return false;
    }
  } catch (error) {
    logError(`Round-trip test failed: ${error.message}`);
    return false;
  }
}

async function testPerformance() {
  logSection('TEST 7: Performance Benchmarks');

  const tests = [
    { name: 'Parse AIX', iterations: 10 },
    { name: 'Validate AIX', iterations: 20 },
    { name: 'Deploy Agent', iterations: 5 },
  ];

  for (const test of tests) {
    log(`\nRunning: ${test.name} (${test.iterations} iterations)`, 'yellow');

    const times = [];
    for (let i = 0; i < test.iterations; i++) {
      const start = Date.now();

      try {
        if (test.name === 'Parse AIX') {
          await axios.post(`${API_BASE_URL}/aix/parse`, {
            aixContent: SAMPLE_AIX_EGYPT_AGENT,
          });
        } else if (test.name === 'Validate AIX') {
          await axios.post(`${API_BASE_URL}/aix/validate`, {
            aixContent: SAMPLE_AIX_EGYPT_AGENT,
          });
        } else if (test.name === 'Deploy Agent') {
          await axios.post(`${API_BASE_URL}/aix/deploy`, {
            aixContent: SAMPLE_AIX_EGYPT_AGENT,
          });
        }

        const elapsed = Date.now() - start;
        times.push(elapsed);
      } catch (error) {
        logError(`Iteration ${i + 1} failed: ${error.message}`);
      }
    }

    if (times.length > 0) {
      const avg = times.reduce((a, b) => a + b, 0) / times.length;
      const min = Math.min(...times);
      const max = Math.max(...times);

      logSuccess(`${test.name} completed`);
      logInfo(`Average: ${avg.toFixed(2)}ms`);
      logInfo(`Min: ${min}ms | Max: ${max}ms`);
    }
  }

  return true;
}

// ============================================================================
// Main Test Runner
// ============================================================================

async function runAllTests() {
  log('\n🧬 AIX SYSTEM COMPREHENSIVE TEST SUITE', 'bright');
  log('Testing Universal AI Agent Format Integration', 'cyan');
  console.log('\n');

  const results = {
    total: 0,
    passed: 0,
    failed: 0,
    tests: [],
  };

  const tests = [
    { name: 'Health Check', fn: testAIXHealth },
    { name: 'Validation', fn: testAIXValidation },
    { name: 'Parsing', fn: testAIXParsing },
    { name: 'Deployment', fn: testAIXDeployment },
    { name: 'Export', fn: testAIXExport },
    { name: 'Round-Trip', fn: testAIXRoundTrip },
    { name: 'Performance', fn: testPerformance },
  ];

  for (const test of tests) {
    results.total++;
    try {
      const passed = await test.fn();
      if (passed) {
        results.passed++;
        results.tests.push({ name: test.name, status: 'PASSED' });
      } else {
        results.failed++;
        results.tests.push({ name: test.name, status: 'FAILED' });
      }
    } catch (error) {
      results.failed++;
      results.tests.push({
        name: test.name,
        status: 'ERROR',
        error: error.message,
      });
      logError(`Test "${test.name}" threw an error: ${error.message}`);
    }
  }

  // Print summary
  logSection('TEST SUMMARY');

  console.log('📊 Results:');
  results.tests.forEach((test) => {
    if (test.status === 'PASSED') {
      log(`   ✅ ${test.name.padEnd(20)} - PASSED`, 'green');
    } else if (test.status === 'FAILED') {
      log(`   ❌ ${test.name.padEnd(20)} - FAILED`, 'red');
    } else {
      log(`   ⚠️  ${test.name.padEnd(20)} - ERROR: ${test.error}`, 'yellow');
    }
  });

  console.log('\n' + '─'.repeat(80));
  log(`\n   Total Tests: ${results.total}`, 'bright');
  log(`   Passed: ${results.passed}`, 'green');
  log(`   Failed: ${results.failed}`, results.failed > 0 ? 'red' : 'green');
  log(
    `   Success Rate: ${((results.passed / results.total) * 100).toFixed(1)}%`,
    'cyan'
  );

  console.log('\n📁 Test outputs saved to:', TEST_OUTPUT_DIR);
  console.log('\n');

  if (results.failed === 0) {
    log('🎉 ALL TESTS PASSED! AIX SYSTEM IS READY FOR PRODUCTION! 🚀', 'green');
  } else {
    log('⚠️  Some tests failed. Review the errors above.', 'yellow');
  }

  console.log('\n');
}

// Run tests
if (require.main === module) {
  runAllTests().catch((error) => {
    logError(`Test suite crashed: ${error.message}`);
    console.error(error);
    process.exit(1);
  });
}

module.exports = { runAllTests };
